# LAB4 REPORT
## 计23　刘鹤　2012011300

### 练习0：填写已有实验
> 在命令行下使用diff和patch命令进行代码整合

### 练习1：分配并初始化一个进程控制块

- 1 设计实现过程
> * 根据代码中的相关注释对一个进程做初始化，即对proc_struct结构体赋初值。以下是赋值时需要注意的几个关键之处：
>> * 结构体state为“未初始化”状态
>> * 进程id设置为-1（因为存在id为0的进程）
>> * 将进程切换上下文结构体(context)全部置0
>> * 将进程的页目录表基址CR3寄存器设置为boot_cr3（此时使用内核页目录表的基址）
- 2 请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用
> * struct context context的作用是在内核对进程进行切换时，需要保存的进程运行的上下文（相关寄存器）
> * struct trapframe *tf表示当前进程在遇到中断时需要保存的寄存器

### 练习2：为新创建的内核线程分配资源

- 1 设计实现过程
> * 根据do_fork函数的大致执行过程
>> * 首先调用alloc_proc函数分配一个进程结构体，并将新生成的进程的父进程置为当前进程
>> * 对子进程分配一个内核堆栈
>> * 复制内存管理模块
>> * 复制父进程的陷入帧和上下文到子进程的相应模块
>> * 为该线程分配一个新的id，并将其插入到进程队列和hash队列中（在进行这一步时，要设置中断的使不能和使能，即在分配新的id的时候不能被中断所打断）
>> * 将进程状态变为RUNNABLE（调用wakeup_proc函数）
>> * 返回值为该子进程id
- 2 请说明ucore是否做到给每个新fork的线程一个唯一的id
> * 能够做到对每个新线程分配一个唯一id。相关代码在get_pid()函数中。该函数将进程链表proc_list进行了遍历，在确保进程号小于最大值的情况下分配一个新的id

### 练习3：理解 proc_run 函数和它调用的函数如何完成进程切换

- 1 在本实验的执行过程中，创建且运行了几个内核线程
> * 两个内核线程，分别是idle_proc和init_proc
- 2 语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用
> * 对中断设置使不能和使能，使得在这两个语句之间的程序块不可被中断打断，成为原子操作

### 自己的实现与参考答案的实现的区别

> * alloc_proc函数的实现基本没什么区别，但是在自己实现的时候试图将bool值赋值为false，但是编译器并不支持这种写法，因此将所有bool值的赋值都变成了0
> * 在do_fork函数中，参考答案的实现对alloc_proc，setup_kstack等函数返回值为空的情况进行了处理，但是在自己的实现中默认返回值不空